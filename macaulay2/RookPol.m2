---------------------------------------------------------------------------------------------------
-- COLLECTIONS OF CELLS, BINOMIAL IDEALS AND SWITCHING ROOK POLYNOMIAL OF COLLECTIONS OF CELLS
---------------------------------------------------------------------------------------------------
--
-- This file is intended to test the conjectures stating that:
--   1. The h-polynomial of the coordinate ring of Q = switching rook polynomial of Q
--   2. Castelnuovo-Mumford regularity of the coordinate ring of Q = rook number of Q
--
-- To this end, it provides functions to:
--   • compute the inner 2-minor ideal of a collection of cells Q,
--   • compute the rook number and the switching rook polynomial of Q,
--   • finally test the conjectures on given input data.
--
-- The code is organized into three corresponding sections, entitled:
--   1. INNER 2-MINOR IDEAL OF A COLLECTION OF CELLS
--   2. SWITCHING ROOK POLYNOMIAL
--   3. TESTING THE CONJECTURES
--
-- Important Note: The Macaulay2 package "Graphs" must be loaded before using the switching
--                 rook functions or TestConj, as these functions rely on graph computations 
--                 to define equivalence among rook configurations:
-- loadPackage "Graphs";
--
-- All functions are implemented in the general setting of collections of cells.
-- A collection is encoded as a list Q, whose elements are the cells, each represented 
-- by its diagonal corners.
--
-- Example:
--     				        __
--  			         __|__|
--   		            |__|__|      
--
--   is encoded as:  Q={{{1,1},{2,2}},{{2,1},{3,2}},{{2,2},{3,3}}}
--
---------------------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------
-- INNER 2-MINOR IDEAL OF A COLLECTION OF CELLS
--
-- This part of the code defines the inner 2-minor ideal 
-- associated with a given collection of cells.
---------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------------------
-- InnerInterval(A,B,Q)
--
-- Given a collection of cells Q and two corners A (lower-left) and B (upper-right),
-- return true if [A,B] is an inner interval in Q, false otherwise.
---------------------------------------------------------------------------------------------------
InnerInterval=(A,B,Q)->(
    C:=B-{1,1};
    if C==A then return true;
    if member({C,B},Q)==false then return false;
    tag=true;
    for i from A#1+1 to B#1 do (
        for j from A#0 to B#0-1 do (
            if member({{j,i-1},{j+1,i}},Q)==false then return false;
        );
    );
    return tag;
);

---------------------------------------------------------------------------------------------------
-- PolyoRing(Q)
--
-- Given a collection of cells Q, return its polynomial ring.
-- Variables are indexed by the vertices of the cells in Q.
---------------------------------------------------------------------------------------------------
-- Although the names PolyoRing and later PolyoIdeal for the ideal of Q refer to "polyominoes", 
-- these functions actually apply to arbitrary collections of cells. The terminology is chosen 
-- to emphasize the connection with polyomino theory.
---------------------------------------------------------------------------------------------------
PolyoRing=(Q)->(
    V={};
    for i from 0 to #Q-1 do(
        V=join(V,toList ({Q#i#0#0,Q#i#0#1}..{Q#i#1#0,Q#i#1#1}));
    );
    V=set V;
    V=rsort(toList(V));
    Gen={};                                      
    for i from 0 to #V-1 do(
        Gen=join(Gen,{x_(V#i#0,V#i#1)});
    );
    R=QQ[Gen];
    return R;
);


---------------------------------------------------------------------------------------------------
-- PolyoIdeal(Q)
--
-- Given a collection of cells Q, return the ideal of the inner 2-minors of Q.
-- This is generated by binomials corresponding to inner intervals of Q.
---------------------------------------------------------------------------------------------------
PolyoIdeal=(Q)->(
    Binomials={};
    for i from 0 to #Q-1 do(
        lLowCorner = Q#i#0;
            for j from 0 to #Q-1 do(
                 rUpCorner = Q#j#1;
                 if lLowCorner#0<rUpCorner#0 and lLowCorner#1<rUpCorner#1 then (
                     if InnerInterval(lLowCorner,rUpCorner,Q) then (
                         a=lLowCorner#0;
                         b=lLowCorner#1;
                         c=rUpCorner#0;
                         d=rUpCorner#1;
                         Binomials=join(Binomials,{x_(a,b)*x_(c,d)-x_(a,d)*x_(c,b)});
                     );
                 );
            );
    );
    Binomials = set Binomials;
    Binomials = toList Binomials;
    I=ideal(Binomials);
    return I;
);


---------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------
-- SWITCHING ROOK POLYNOMIAL 
--
-- This part of the code computes the switching rook polynomial 
-- of a given collection of cells.
---------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------------------
-- isNonAttackingRooks(A,B,Q)
--
-- Test if two rooks, identified with cells A and B, are in non-attacking position.
-- Return true if they do not attack each other in Q, false otherwise.
---------------------------------------------------------------------------------------------------
isNonAttackingRooks=(A,B,Q)->(
    a:=min{A#0#0,B#0#0};
    b:=min{A#0#1,B#0#1};
    c:=max{A#1#0,B#1#0};
    d:=max{A#1#1,B#1#1};
    if (A#0#0==B#0#0 or A#0#1==B#0#1) then(
        return not(InnerInterval({a,b},{c,d},Q));
    );
    return true;
);

---------------------------------------------------------------------------------------------------
-- AllNonAttackingRookConfigurations(Q)
--
-- This function computes all possible non-attacking rook configurations 
-- on a given collection of cells Q. Each configuration is represented 
-- as a list of cells.
--
-- The output is organized as a list of lists, where each sublist contains
-- all configurations of a given size:
--   - The first sublist contains all configurations with 1 rook,
--   - The second sublist contains all configurations with 2 rooks,
--   - And so on, up to the maximum number of non-attacking rooks that can 
--     be placed on Q (that is, the rook number of Q).
-- This ordering by cardinality is convenient for computing the coefficients 
-- of the switching rook polynomial and for determining the rook number of Q.
---------------------------------------------------------------------------------------------------
AllNonAttackingRookConfigurations=(Q) -> (
    Q = sort Q;
    conf = apply(Q, i -> {i}); 
    AllConf = {conf};
    while true do (
        out = {};
        for N in conf do (
            for c in Q do (
                if all(N, n -> isNonAttackingRooks(c, n, Q)) then (
                    FF = sort join(N, {c});
                    out = join(out, {FF});
                );
            );
        );
        out = toList set out; 
        if #out == 0 then return AllConf;
        AllConf = append(AllConf, out);
        conf = out;
    );
);

---------------------------------------------------------------------------------------------------
-- RookNumber(Q)
--
-- Compute the rook number of a collection of cells Q, i.e., the maximum number 
-- of non-attacking rooks that can be placed on Q.
--
-- Note: This function is provided for completeness as a standalone utility. 
-- In practice, the same information can be obtained from the last element 
-- of AllNonAttackingRookConfigurations(Q).
---------------------------------------------------------------------------------------------------
RookNumber = (Q) -> (
    return #(AllNonAttackingRookConfigurations(Q));
);

---------------------------------------------------------------------------------------------------
-- SwitchOperation(A,B,Q)
--
-- Given two rooks A and B in Q, check if they are in switching position.
-- If so, return the switched configuration; otherwise return {}.
---------------------------------------------------------------------------------------------------
SwitchOperation=(A,B,Q)->(
       a:=min{A#0#0,B#0#0};
       b:=min{A#0#1,B#0#1};
       c:=max{A#1#0,B#1#0};
       d:=max{A#1#1,B#1#1};
       if InnerInterval({a,b},{c,d},Q) then (
		if A#0 == {a,b} or A#0 == {c-1,d-1} then return {{{a,d-1},{a+1,d}},{{c-1,b},{c,b+1}}};
		if A#0 == {a,d-1} or A#0 == {c-1,b} then return {{{a,b},{a+1,b+1}},{{c-1,d-1},{c,d}}};	
	) else return {};
);

---------------------------------------------------------------------------------------------------
-- areSwitchEquivalent(R1,R2,Q)
--
-- Test if two rook configurations R1 and R2 are switch-equivalent in Q,
-- i.e., if one can be obtained from the other by a single switch operation.
---------------------------------------------------------------------------------------------------
areSwitchEquivalent = (R1,R2,Q) -> ( 
diff1 := R1 - set R2; 
diff2 := R2 - set R1; 
if #diff1 == #diff2 and #diff2 == 2 then (
	if set(diff1) === set(SwitchOperation(diff2#0,diff2#1,Q)) or set(diff2) === set(SwitchOperation(diff1#0,diff1#1,Q)) then return true else return false;
) else return false; 
);

---------------------------------------------------------------------------------------------------
-- CoeffSwitchingRookPolynomial(Q)
--
-- Compute the list in increasing order of the coefficients of the switching rook polynomial of Q,
-- as the list of coefficients {1, c1, c2, ...}.
--
-- Important Note, before using: loadPackage "Graphs"
---------------------------------------------------------------------------------------------------
CoeffSwitchingRookPolynomial = (Q) -> (

    RookConf := AllNonAttackingRookConfigurations(Q); 
    rookNumber := #RookConf;
    coeffRookPol := {1};

    for k from 0 to rookNumber-1 do(
    kRookSet := RookConf#k;
    verticesForGraph := new MutableHashTable;
    for i from 0 to #kRookSet-1 do verticesForGraph#i = kRookSet#i;
    edgesForGraph = {};
    for i from 0 to #kRookSet-2 do (
        for j from i+1 to #kRookSet-1 do (
            if areSwitchEquivalent(verticesForGraph#i, verticesForGraph#j, Q) then (
                edgesForGraph = join(edgesForGraph, {{i,j}});
            );
        );
     );	
    GraphRook = graph(toList(0 .. #kRookSet-1), edgesForGraph);
    kCoeff = #connectedComponents GraphRook;
    coeffRookPol = join(coeffRookPol,{kCoeff});
    );
return coeffRookPol;
);

---------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------
-- TESTING THE CONJECTURE
--
-- In the final part of the code, we test the conjecture stating that the h-polynomial of the 
-- coordinate ring of a collection of cells coincides with its switching rook polynomial.
---------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------------------
-- TestConj(L)
--
-- Given a list L of collections of cells, test the conjectures:
-- 1. h-polynomial of the coordinate ring of L#i == switching rook polynomial of L#i
-- 2. Castelnuovo-Mumford regularity of the coordinate ring of L#i == rook number of L#i
--
-- If the conjecture holds for all elements, print "Conjecture is ok".
-- Otherwise, return the list of counterexamples.
--
-- Important Note, before using: loadPackage "Graphs"
---------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------

TestConj=(L)->(
ControlList = {};
numberCollections = #L;

for i from 0 to #L-1 do(
	if i%250 == 0 then print("Iteration " | toString(i+1) | " over " | toString(numberCollections));
	R=PolyoRing(L#i);
	I=PolyoIdeal(L#i);
	
	hVector = flatten entries ((coefficients numerator reduceHilbert hilbertSeries I)#1);
	SwitchPol = CoeffSwitchingRookPolynomial(L#i);

	rooknum = #(SwitchPol) - 1;
	reg = regularity I - 1;

	if not(hVector == SwitchPol and rooknum == reg) then ControlList = append(ControlList, L#i);
	);		

if ControlList == {} then print("Conjecture is ok") else return ControlList; 
);

---------------------------------------------------------------------------------------------------
-- EXAMPLE OF USE

-- loadPackage "Graphs";
-- load "RookPol.m2";
-- L = value get("weak_polyplets_n4.txt");
-- TestConj(L);
---------------------------------------------------------------------------------------------------
